{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(1, 1, 1); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(1, 1, 1); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"circle","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.2560 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.4740035931183971, 0.39497828227738974); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0108 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0108 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); falloff = 1.0 - falloff; vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0.7607843137254902, 0.8666666666666667, 1), 1.0000), falloff); color.rgb = finalColor; color.a = mix(1.0 - falloff, 1.0, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"circle","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src * dst; }out vec4 fragColor;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.2000 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.7284524483698456, 0.6423142695340942); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(-0.0135 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(-0.0135 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); falloff = 1.0 - falloff; vec3 finalColor;vec3 blended = blend(3, vec3(0.7607843137254902, 0.8666666666666667, 1), color.rgb); finalColor = mix(color.rgb, blended, falloff * 1.0000); color.rgb = finalColor; color.a = mix(1.0 - falloff, 1.0, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"circle","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src * dst; }out vec4 fragColor;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.5000, 1.0 - 0.5000); float halfRadius = 0.1880 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.6, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(-0.0243 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(-0.0243 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); falloff = 1.0 - falloff; vec3 finalColor;vec3 blended = blend(3, vec3(0.27058823529411763, 0.6039215686274509, 1), color.rgb); finalColor = mix(color.rgb, blended, falloff * 1.0000); color.rgb = finalColor; color.a = mix(1.0 - falloff, 1.0, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"flowField","usesPingPong":false,"speed":0.25,"trackMouse":0.1,"trackAxes":"xy","mouseMomentum":0.26,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x); float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }const float MAX_ITERATIONS = 16.; vec2 flow (in vec2 st) { float aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.1000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(st * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));float sprd = (0.4000 + 0.01) / ((aspectRatio + 1.) / 2.); float amt = 1.8000 * 0.01 * dist; if(amt <= 0.) { return st; }for (float i = 0.; i < MAX_ITERATIONS; i++) { vec2 scaled = (st-0.5) * vec2(aspectRatio, 1) + (1. - pos); float perlin = perlin_noise(vec3((scaled-0.5) * (5. * sprd), 1.0000*5. + uTime/60.))-0.5; float ang = (perlin * (360. * (0.3267 * 6.))) * 3.1415926 / 180.; st += vec2(cos(ang), sin(ang)) * amt; st = clamp(st, 0., 1.); }return st; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, mix(uv, flow(uv), 0.3300)); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"progressiveBlur","usesPingPong":false,"trackMouse":0.3,"trackAxes":"y","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.7169735788630904, 0.721617293835068) + mix(vec2(0), (uMousePos-0.5), 0.3000);float amt = 6.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 1.0000 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0);vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, false); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.7169735788630904, 0.721617293835068) + mix(vec2(0), (uMousePos-0.5), 0.3000);float amt = 6.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 1.0000 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0);vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, false); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 directionalBlur(vec2 uv, bool isVertical) { vec4 color = vec4(0.0); vec2 pos = vec2(0.7169735788630904, 0.721617293835068) + mix(vec2(0), (uMousePos-0.5), 0.3000);float amt = 6.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 1.0000 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0);vec2 direction = isVertical ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; vec2 offset = vec2(x * 0.001) * direction; color += texture(uTexture, uv + offset) * getGaussianWeight(i); }float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb += dither;return color; }vec4 getColor(vec2 uv) { return directionalBlur(uv, true); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor;const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 finalBlur(vec2 uv) { vec4 color = vec4(0.0); vec2 pos = vec2(0.7169735788630904, 0.721617293835068) + mix(vec2(0), (uMousePos-0.5), 0.3000);float amt = 11.;vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float amount = 1.0000 * amt * dist * jawn;if (amount < 0.0001) { return texture(uTexture, uv); } color += texture(uTexture, uv) * getGaussianWeight(0); for (int i = 0; i < kernelSize; i++) { float x = float(i - kernelSize / 2) * amount; color += texture(uTexture, uv + vec2(x * 0.001, 0)) * getGaussianWeight(i) * 0.5; color += texture(uTexture, uv + vec2(0, x * 0.001) * vec2(1, uResolution.x/uResolution.y)) * getGaussianWeight(i) * 0.5; }return color; }vec4 getColor(vec2 uv) { return finalBlur(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}","#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform sampler2D uBgTexture; uniform vec2 uMousePos;out vec4 fragColor;float random(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }const float PI = 3.141592;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }float easeInOutQuad(float t) { return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t; }const int kernelSize = 36;vec4 composite(vec2 uv) { vec4 bg = texture(uBgTexture, uv); vec4 fg = texture(uTexture, uv); float dither = (random(gl_FragCoord.xy) - 0.5) / 255.0; fg.rgb += dither;vec2 pos = vec2(0.7169735788630904, 0.721617293835068) + mix(vec2(0), (uMousePos-0.5), 0.3000);vec2 st = uv * rot(0.0000 * 2. * PI); pos *= rot(0.0000 * 2. * PI);float dist = easeInOutQuad(pos.y - st.y); float jawn = st.y < pos.y ? 1. : 0.;float m = 1.0000 * 11. * dist * jawn; return mix(fg, bg, smoothstep(1.0, 0.0, m)); }vec4 getColor(vec2 uv) { return composite(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"downSample":0.25,"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":0,"downSample":0.25},{"prop":"pass","value":1,"downSample":0.5},{"prop":"pass","value":2,"downSample":0.5},{"prop":"pass","value":3,"includeBg":true}]},"id":"effect5"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"waterRipple","usesPingPong":true,"speed":0.75,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uPingPongTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 calculateNormal(sampler2D tex, vec2 uv) { float stengthScale = mix(3., 7., 0.6000); float stepScale = mix(1., 3., 0.6000); float strength = mix(1., stengthScale, 0.5300); float stepSize = mix(1., stepScale, 0.5300); float step = stepSize / 1080.; float left = texture(tex, uv + vec2(-step, 0.0)).r; float right = texture(tex, uv + vec2(step, 0.0)).r; float top = texture(tex, uv + vec2(0.0, -step)).r; float bottom = texture(tex, uv + vec2(0.0, step)).r; vec3 normal; normal.x = (right - left) * strength; normal.y = -(bottom - top) * strength; normal.z = -1.0; return normalize(normal); }vec4 drawRipple(vec2 uv) { vec2 scaled = mix(uv, (uv - 0.5) * 0.5 + 0.5, 0.6000); vec3 normal = calculateNormal(uPingPongTexture, scaled); return vec4(normal, 1.); }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec4 getColor(vec2 uv) { return drawRipple(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;float getGaussianWeight(int index) { switch(index) { case 0: return 0.7978845608028654; case 1: return 0.795118932516684; case 2: return 0.7868794322038799; case 3: return 0.7733362336056986; case 4: return 0.7547664553859864; case 5: return 0.7315447328280048; case 6: return 0.704130653528599; case 7: return 0.6730536454899063; case 8: return 0.6388960110447045; case 9: return 0.6022748643096089; case 10: return 0.5638237508206051; case 11: return 0.5241747061566029; case 12: return 0.48394144903828673; case 13: return 0.443704309411472; case 14: return 0.40399737110811773; case 15: return 0.36529817077804383; case 16: return 0.3280201493519873; case 17: return 0.29250790855907144; case 18: return 0.2590351913317835; case 19: return 0.2278053882403838; case 20: return 0.19895427758549736; case 21: return 0.17255463765302306; case 22: return 0.1486223271179862; case 23: return 0.12712341303392466; default: return 0.0; } }out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) { vec4 color = vec4(0.0); float total_weight = 0.0; vec4 center = texture(uTexture, uv); float center_weight = getGaussianWeight(0); color += center * center_weight; total_weight += center_weight; for (int i = 1; i <= 11; i++) { float weight = getGaussianWeight(i); float offset = mix(0.005, 0.015, 0.0000) * float(i)/11.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec4 getColor(vec2 uv) { return blur(uv, vec2(1, 0)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;float getGaussianWeight(int index) { switch(index) { case 0: return 0.7978845608028654; case 1: return 0.795118932516684; case 2: return 0.7868794322038799; case 3: return 0.7733362336056986; case 4: return 0.7547664553859864; case 5: return 0.7315447328280048; case 6: return 0.704130653528599; case 7: return 0.6730536454899063; case 8: return 0.6388960110447045; case 9: return 0.6022748643096089; case 10: return 0.5638237508206051; case 11: return 0.5241747061566029; case 12: return 0.48394144903828673; case 13: return 0.443704309411472; case 14: return 0.40399737110811773; case 15: return 0.36529817077804383; case 16: return 0.3280201493519873; case 17: return 0.29250790855907144; case 18: return 0.2590351913317835; case 19: return 0.2278053882403838; case 20: return 0.19895427758549736; case 21: return 0.17255463765302306; case 22: return 0.1486223271179862; case 23: return 0.12712341303392466; default: return 0.0; } }out vec4 fragColor;vec4 blur(vec2 uv, vec2 dir) { vec4 color = vec4(0.0); float total_weight = 0.0; vec4 center = texture(uTexture, uv); float center_weight = getGaussianWeight(0); color += center * center_weight; total_weight += center_weight; for (int i = 1; i <= 11; i++) { float weight = getGaussianWeight(i); float offset = mix(0.005, 0.015, 0.0000) * float(i)/11.; vec4 sample1 = texture(uTexture, uv + offset * dir); vec4 sample2 = texture(uTexture, uv - offset * dir); color += (sample1 + sample2) * weight; total_weight += 2.0 * weight; }return color / total_weight; }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec4 getColor(vec2 uv) { return blur(uv, vec2(0, 1)); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uTexture; uniform sampler2D uBgTexture;const float PI = 3.1415926; const float ITERATIONS = 24.0;out vec4 fragColor;vec3 chromatic_aberration(vec3 color, vec2 uv) { vec2 offset = (uv - vTextureCoord) * (0.6300 * 0.2); vec4 left = texture(uBgTexture, uv - offset); vec4 right = texture(uBgTexture, uv + offset);color.r = left.r; color.b = right.b;return color; }vec2 calculateRefraction(vec3 normal, float ior) { vec3 I = vec3(0.0, 0.0, 1.0); float ratio = 1.0 / ior; vec3 refracted = refract(I, normal, ratio); float refractionScale = mix(0.2, 0.4, 0.6000); float refractionAmount = mix(0.01, refractionScale, 0.5300); return refracted.xy * refractionAmount; }const vec3 LIGHT_POS = vec3(2.0, 2.0, 3.0); const vec3 VIEW_POS = vec3(0.0, 0.0, 2.0); const float SPECULAR = 2.4; const float SHININESS = 128.0;vec3 calculateLighting(vec3 normal, vec2 uv) { vec3 N = normal; vec3 worldPos = vec3(uv * 2.0 - 1.0, 0.0); vec3 lightDir = normalize(LIGHT_POS - worldPos); vec3 viewDir = normalize(VIEW_POS - worldPos); vec3 reflectDir = reflect(-lightDir, N); float diff = max(dot(N, lightDir), 0.0); vec3 diffuse = vec3(diff); float spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS); vec3 specular = vec3(spec * SPECULAR); return diffuse + specular; }vec4 getRipple(vec2 uv) { vec3 normal = texture(uTexture, uv).rgb; vec2 refractionOffset = calculateRefraction(normal, 1.333); vec2 refractedUv = uv + refractionOffset; vec3 refractedNormal = texture(uTexture, refractedUv).rgb;vec4 refractedColor = texture(uBgTexture, refractedUv); refractedColor.rgb = chromatic_aberration(refractedColor.rgb, refractedUv);vec3 caustics = calculateLighting(refractedNormal, refractedUv); float causticsShadow = dot(normal, normalize(vec3(2.0, -2.0, 3.0) - vec3(uv * 2.0 - 1.0, 0.0))) + 1.; float shadowFactor = causticsShadow; vec3 lightingFactor = caustics;shadowFactor = mix(1., shadowFactor, 0.5000); lightingFactor = mix(vec3(0), lightingFactor * vec3(1, 1, 1), 0.5000); vec4 finalColor = vec4(refractedColor.rgb - vec3(1.-shadowFactor) * vec3(1, 1, 1) + lightingFactor, refractedColor.a); return finalColor; }vec4 getColor(vec2 uv) { return getRipple(uv); }void main() { vec2 uv = vTextureCoord; vec4 color = getColor(uv); fragColor = color; }","#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uPingPongTexture; uniform vec2 uPreviousMousePos;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI = 3.1415926; const float TWOPI = 6.2831852;out vec4 fragColor;void main() { vec2 aspect = vec2(uResolution.x/uResolution.y, 1); vec2 texelSize = (1.0 / (vec2(1080) * aspect)) * mix(1., 8., 0.7500); vec2 vUv = vTextureCoord; vec2 mPos = mix(uMousePos, (uMousePos - 0.5) * 0.5 + 0.5, 0.6000); vec2 pmPos = mix(uPreviousMousePos, (uPreviousMousePos - 0.5) * 0.5 + 0.5, 0.6000);float waveSpeed = 1.; float damping = mix(0.8, 0.999, 0.7500); float velocityDamping = damping; float heightDamping = damping; float time = 0.5;vec4 data = texture(uPingPongTexture, vUv); float height = data.r; float velocity = data.g;float laplacian = 0.0; float totalWeight = 0.0; float scaleDiff = 0.6000 * 0.25; vec2 clampRegionMin = vec2(0.6000 * 0.5 - scaleDiff); vec2 clampRegionMax = vec2(1.0 - 0.6000 * 0.5 + scaleDiff); vec2 offset = vec2(texelSize.x, 0.0); vec2 neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); float weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight; offset = vec2(-texelSize.x, 0.0); neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight; offset = vec2(0.0, texelSize.y); neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight; offset = vec2(0.0, -texelSize.y); neighborUv = clamp(vUv + offset, clampRegionMin, clampRegionMax); weight = 1.0 - length(offset) / (length(texelSize) * 2.0); laplacian += texture(uPingPongTexture, neighborUv).r * weight; totalWeight += weight;float avgNeighbors = laplacian / totalWeight; laplacian = avgNeighbors - height;velocity += waveSpeed * waveSpeed * laplacian; velocity *= velocityDamping; height += velocity; height *= heightDamping;float mouseSpeed = distance(mPos * aspect, pmPos * aspect); float dist = distance(vUv * aspect, mPos * aspect); float radius = 0.025; if (dist < radius && mouseSpeed > 0.0001) { float drop = cos(dist / radius * PI * time); float intensity = mouseSpeed * 20.; height += drop * intensity; }fragColor = vec4(height, velocity, 0.0, 1.0); }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }","#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"depth":false,"uniforms":{},"isBackground":false,"passes":[{"prop":"pass","value":1,"downSample":true},{"prop":"pass","value":2,"downSample":true},{"prop":"pass","value":3,"includeBg":true}]},"id":"effect6"}],"options":{"name":"Birds of Paradise (Remix)","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"1.4.31","id":"ty3N7ZPaIU7KlWixQFIc"}